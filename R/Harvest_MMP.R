
#' Harvest component of operating model
#'
#' A function used by openMSE to specify the fishing effort during the projections.
#' salmonMSE updates the arguments of this function from the salmon operating model.
#'
#' @param x Simulation number
#' @param DataList A nested list of \linkS4class{Data} objects by stock then fleet, generated by [multiMSE()]
#' @param reps The number of stochastic replicates to be returned by the function
#' @param u_terminal Harvest rate of retained catch in the terminal fishery
#' @param u_preterminal Harvest rate of retained catch in the pre-terminal fishery
#' @param m Mark rate of hatchery origin fish, as a proxy for fishery retention. Only used to calculate the fishing effort.
#' Retention in the operating model is specified in the \linkS4class{MOM} object
#' @param release_mort Length two numeric for the release mortality of discarded fish in the pre-terminal and terminal fishery. Only used to calculate the fishing effort.
#' Release mortality in the operating model is specified in the \linkS4class{MOM} object
#' @param p_terminal Population index for the recruitment that experiences the terminal fishing mortality
#' @param p_preterminal Population index for immature fish that experience the pre-terminal fishing mortality
#' @param p_natural Population index for natural origin fish
#' @param p_hatchery Population index for hatchery origin fish
#'
#' @param ... Not used
#'
#' @return A nested list of \linkS4class{Rec} objects, same dimension as `DataList`
#'
#' @keywords internal
Harvest_MMP <- function(x = 1, DataList, reps = 1, u_terminal, u_preterminal, m, release_mort,
                        p_terminal = c(2, 5), p_preterminal = c(1, 4),
                        p_natural = 1:3, p_hatchery = 4:6, ...) {
  np <- length(DataList)
  nf <- length(DataList[[1]])

  p_preterminal <- intersect(1:np, p_preterminal)
  p_terminal <- intersect(1:np, p_terminal)

  multiRec <- lapply(1:np, function(p) {
    y <- max(DataList[[1]][[1]]@Year) - DataList[[1]][[1]]@LHYear + 1
    nyears <- length(DataList[[1]][[1]]@Misc$FleetPars$Find[x, ])

    Nage_p <- rowSums(DataList[[p]][[1]]@Misc$StockPars$N_P[x, , y, ])

    if (!sum(Nage_p)) {
      Effort <- 0
    } else if (p %in% p_preterminal) {
      odd_time_step <- y %% 2
      Nage_PT <- sapply(p_preterminal, function(pp) rowSums(DataList[[pp]][[1]]@Misc$StockPars$N_P[x, , y, ]))
      if (u_preterminal > 0 && odd_time_step) {
        V <- sapply(p_preterminal, function(pp) DataList[[pp]][[1]]@Misc$FleetPars$V[x, , nyears + y]) %>%
          apply(1, unique)

        if (m > 0) { # MSF, Specify F here, further retention and discards handled by OM
          Nage_HOS_PT <- sapply(intersect(p_preterminal, p_hatchery), function(pp) rowSums(DataList[[pp]][[1]]@Misc$StockPars$N_P[x, , y, ]))
          Effort <- get_F(
            u = u_preterminal, M = rep(0, length(Nage_p)),
            N = rowSums(Nage_HOS_PT), # Kept catch of HOS
            vul = V, ret = m,
            release_mort = release_mort[1]
          )
        } else {
          Effort <- get_F(
            u = u_preterminal, M = rep(0, length(Nage_p)),
            N = rowSums(Nage_PT), vul = V, ret = 1
          )
        }

      } else {
        Effort <- 0
      }
    } else if (p %in% p_terminal) {
      even_time_step <- !y %% 2
      Nage_T <- sapply(p_terminal, function(pp) rowSums(DataList[[pp]][[1]]@Misc$StockPars$N_P[x, , y, ]))
      if (u_terminal > 0 && even_time_step) {
        V <- sapply(p_terminal, function(pp) DataList[[pp]][[1]]@Misc$FleetPars$V[x, , nyears + y]) %>%
          apply(1, unique)

        if (m > 0) {
          Nage_HOS_T <- sapply(intersect(p_terminal, p_hatchery), function(pp) rowSums(DataList[[pp]][[1]]@Misc$StockPars$N_P[x, , y, ]))

          Effort <- get_F(
            u = u_terminal, M = rep(0, length(Nage_p)),
            N = rowSums(Nage_HOS_T), # Kept catch of HOS
            vul = V, ret = m,
            release_mort = release_mort[2]
          )
        } else {
          Effort <- get_F(
            u = u_terminal, M = rep(0, length(Nage_p)),
            N = rowSums(Nage_T), vul = V, ret = 1
          )
        }

      } else {
        Effort <- 0
      }
    } else { # Escapement
      Effort <- 0
    }

    lapply(1:nf, function(f) {
      Rec <- new("Rec")
      HistE <- DataList[[p]][[f]]@OM$FinF[x] # Last historical fishing effort
      Rec@Effort <- rep(Effort/HistE, reps)
      return(Rec)
    })
  })

  return(multiRec)
}

#' Harvest component of salmon operating model
#'
#' A function that creates a multi-stock management procedure
#'
#' @param u_terminal Numeric between 0-1. Harvest rate of the terminal fishery.
#' @param u_preterminal Numeric between 0-1. Harvest rate of the preterminal fishery.
#' @param m Numeric between 0-1. Mark rate, i.e., retention rate.
#' @param release_mort Vector length 2 (each numeric between 0-1). Release mortality, proportion of released fish that die.
#' @export
make_Harvest_MMP <- function(u_terminal = 0.1, u_preterminal = 0, m = 0, release_mort = 0) {
  f <- Harvest_MMP
  formals(f)$u_terminal <- u_terminal
  formals(f)$u_preterminal <- u_preterminal
  formals(f)$m <- m
  formals(f)$release_mort <- release_mort
  class(f) <- "MMP"
  return(f)
}

#' Calculate F from harvest rate
#'
#' Solves for apical instantaneous fishing mortality rate from harvest rate (total retained catch over total abundance).
#'
#' @param u Harvest rate, between 0-1
#' @param M Instantaneous natural mortality rate
#' @param N Abundance
#' @param vul Vulnerability
#' @param ret Retention rate, between 0-1
#' @param release_mort Release mortality as a proportion, between 0-1. Only relevant if `ret < 1`
#' @param Fmax Maximum allowable value of F
#' @return Numeric for the apical F
#'
#' @keywords internal
#'
#' @importFrom stats uniroot
get_F <- function(u = 0, M, N = 1, vul = 1, ret = 1, release_mort = 0, Fmax = 20) {
  if (u > 0) {
    .F <- try(
      uniroot(F_solver, interval = c(1e-8, Fmax), M = M, N = N, vul = vul, ret = ret, release_mort = release_mort, u = u),
      silent = TRUE
    )
    if (is.character(.F)) {
      return(Fmax)
    } else {
      return(.F$root)
    }
  } else {
    return(0)
  }
}

F_solver <- function(.F, M, N = 1, vul = 1, ret = 1, release_mort = 0, u = 0) {
  F_ret <- vul * ret * .F
  F_rel <- vul * (1 - ret) * release_mort * .F
  Z <- F_ret + F_rel + M
  catch_ret <- F_ret/Z * (1 - exp(-Z)) * N
  catch_ret[is.na(catch_ret)] <- 0
  sum(catch_ret)/sum(vul * N) - u
}


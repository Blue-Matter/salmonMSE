
#' Harvest component of operating model
#'
#' A function used by openMSE to specify the fishing effort during the projections.
#' salmonMSE updates the arguments of this function from the salmon operating model.
#'
#' @param x Simulation number
#' @param DataList A nested list of \linkS4class{Data} objects by stock then fleet, generated by [multiMSE()]
#' @param reps The number of stochastic replicates to be returned by the function
#' @param u_terminal Numeric vector by population (s). Harvest rate of retained catch in the terminal fishery
#' @param u_preterminal Single numeric. Harvest rate of retained catch in the pre-terminal fishery
#' @param MSF Logical, whether to implement mark-selective fishing
#' @param m Numeric vector by population (s). Mark rate of hatchery origin fish, as a proxy for fishery retention. Only used to calculate the fishing effort.
#' Retention in the operating model is specified in the \linkS4class{MOM} object
#' @param release_mort Matrix `[2, s]`. Release mortality of discarded fish in the pre-terminal (1st row) and terminal (2nd row) fishery. Only used
#' if `MSF = TRUE`. Only used to calculate the fishing effort.
#' Release mortality in the operating model is specified in the \linkS4class{MOM} object
#' @param p_terminal Numeric vector. Population index (p) for the recruitment that experiences the terminal fishing mortality
#' @param p_preterminal Numeric vector. Population index (p) for immature fish that experience the pre-terminal fishing mortality
#' @param p_natural Numeric vector. Population index (p) for natural origin fish
#' @param p_hatchery Numeric vector. Population index (p) for hatchery origin fish
#' @param pkey Data frame that assigns openMSE population by life stage and origin (p) to salmonMSE population (s)
#'
#' @param ... Not used
#'
#' @return A nested list of \linkS4class{Rec} objects, same dimension as `DataList`
#'
#' @keywords internal
Harvest_MMP <- function(x = 1, DataList, reps = 1, u_terminal, u_preterminal, MSF = FALSE, m, release_mort,
                        p_terminal = c(2, 5), p_preterminal = c(1, 4), pkey = data.frame(p = 1:6, s = 1),
                        p_natural = 1:3, p_hatchery = 4:6, ...) {
  np <- length(DataList)
  nf <- length(DataList[[1]])

  #p_preterminal <- intersect(1:np, p_preterminal)
  #p_terminal <- intersect(1:np, p_terminal)

  multiRec <- lapply(1:np, function(p) {
    y <- max(DataList[[1]][[1]]@Year) - DataList[[1]][[1]]@LHYear + 1
    nyears <- length(DataList[[1]][[1]]@Misc$FleetPars$Find[x, ])

    Nage_p <- rowSums(DataList[[p]][[1]]@Misc$StockPars$N_P[x, , y, ])

    if (!sum(Nage_p)) {
      Effort <- 0
    } else if (p %in% p_preterminal) {

      odd_time_step <- y %% 2

      if (u_preterminal > 0 && odd_time_step) {

        # MSF, Specify F here, further retention and discards handled by OM
        if (MSF) {
          p_HOS_PT <- intersect(p_preterminal, p_hatchery)
          Nage_PT <- sapply(p_HOS_PT, function(pp) rowSums(DataList[[pp]][[1]]@Misc$StockPars$N_P[x, , y, ]))
          V_PT <- sapply(p_HOS_PT, function(pp) DataList[[pp]][[1]]@Misc$FleetPars$V[x, , nyears + y])
          s_PT <- pkey$s[match(p_HOS_PT, pkey$p)]

          Effort <- get_F(
            u = u_preterminal, M = array(0, dim(Nage_HOS_PT)), N = Nage_PT, # Kept catch of HOS
            vul = V_PT, ret = m[s_PT], release_mort = release_mort[1, s_PT]
          )
        } else {
          # Mixed stock fishery, specify availability of all immature fish
          Nage_PT <- sapply(p_preterminal, function(pp) rowSums(DataList[[pp]][[1]]@Misc$StockPars$N_P[x, , y, ]))
          V_PT <- sapply(p_preterminal, function(pp) DataList[[pp]][[1]]@Misc$FleetPars$V[x, , nyears + y])

          Effort <- get_F(
            u = u_preterminal, M = array(0, dim(Nage_PT)), N = Nage_PT,
            vul = V_PT, ret = 1
          )
        }

      } else {
        Effort <- 0
      }
    } else if (p %in% p_terminal) {

      even_time_step <- !y %% 2

      s_p <- pkey$s[match(p, pkey$p)]

      if (u_terminal[s_p] > 0 && even_time_step) {

        # Single stock fishery, specify availability of all mature fish in the same population (s)
        if (MSF) {
          p_HOS_T_all <- intersect(p_terminal, p_hatchery)
          p_HOS_T <- intersect(p_HOS_T_all, pkey$p[pkey$s == s_p])

          Nage_T <- sapply(p_HOS_T, function(pp) rowSums(DataList[[pp]][[1]]@Misc$StockPars$N_P[x, , y, ]))
          V_T <- sapply(p_HOS_PT, function(pp) DataList[[pp]][[1]]@Misc$FleetPars$V[x, , nyears + y])
          s_T <- pkey$s[match(p_HOS_T, pkey$p)]

          Effort <- get_F(
            u = u_terminal[s_p], M = array(0, dim(Nage_T)), N = Nage_T, # Kept catch of HOS
            vul = V_T, ret = m[s_T], release_mort = release_mort[2, s_T]
          )
        } else {

          p_T <- intersect(p_terminal, pkey$p[pkey$s == s_p])

          Nage_T <- sapply(p_T, function(pp) rowSums(DataList[[pp]][[1]]@Misc$StockPars$N_P[x, , y, ]))
          V_T <- sapply(p_T, function(pp) DataList[[pp]][[1]]@Misc$FleetPars$V[x, , nyears + y])

          Effort <- get_F(
            u = u_terminal[s_p], M = array(0, dim(Nage_T)), N = Nage_T,
            vul = V_T, ret = 1
          )
        }

      } else {
        Effort <- 0
      }
    } else { # Escapement
      Effort <- 0
    }

    lapply(1:nf, function(f) {
      Rec <- new("Rec")
      HistE <- DataList[[p]][[f]]@OM$FinF[x] # Last historical fishing effort
      Rec@Effort <- rep(Effort/HistE, reps)
      return(Rec)
    })
  })

  return(multiRec)
}

#' @rdname salmonMSE-int
#' @return
#' `make_Harvest_MMP`: Function of class "MMP" by updating the formal arguments for [Harvest_MMP()]
#' @export
make_Harvest_MMP <- function(SOM, check = TRUE) {

  if (check) SOM <- check_SOM(SOM)

  pindex <- make_stock_index(SOM)

  f <- Harvest_MMP
  formals(f)$u_terminal <- vapply(SOM@Harvest, slot, numeric(1), "u_terminal")   # By population
  formals(f)$u_preterminal <- SOM@Harvest[[1]]@u_preterminal                     # One number for all
  formals(f)$MSF <- SOM@Harvest[[1]]@MSF                                         # Currently MSF for all
  formals(f)$m <- vapply(SOM@Hatchery, slot, numeric(1), "m")                    # By population
  formals(f)$release_mort <- vapply(SOM@Harvest, slot, numeric(2), "release_mort") # 2 x ns matrix
  formals(f)$p_preterminal <- pindex$p[pindex$stage == "juvenile"]
  formals(f)$p_terminal <- pindex$p[pindex$stage == "recruitment"]
  formals(f)$p_natural <- pindex$p[pindex$origin == "natural"]
  formals(f)$p_hatchery <- pindex$p[pindex$origin == "hatchery"]
  formals(f)$pkey <- pindex[, c("s", "p")]
  class(f) <- "MMP"
  return(f)
}

#' Calculate F from harvest rate
#'
#' Solves for apical instantaneous fishing mortality rate from harvest rate (total retained catch over total abundance).
#'
#' @param u Harvest rate, between 0-1
#' @param M Instantaneous natural mortality rate
#' @param N Abundance
#' @param vul Vulnerability
#' @param ret Retention rate
#' @param release_mort Release mortality as a proportion, between 0-1. Only relevant if `ret < 1`.
#' @param Fmax Maximum allowable value of F
#' @return Numeric for the apical F
#'
#' @keywords internal
#'
#' @importFrom stats uniroot
get_F <- function(u = 0, M, N = 1, vul = 1, ret = 1, release_mort = 0, Fmax = 20) {
  if (u > 0) {
    .F <- try(
      uniroot(F_solver, interval = c(1e-8, Fmax), M = M, N = N, vul = vul, ret = ret, release_mort = release_mort, u = u),
      silent = TRUE
    )
    if (is.character(.F)) {
      return(Fmax)
    } else {
      return(.F$root)
    }
  } else {
    return(0)
  }
}

F_solver <- function(.F, M, N = 1, vul = 1, ret = 1, release_mort = 0, u = 0) {
  F_ret <- vul * ret * .F
  F_rel <- vul * (1 - ret) * release_mort * .F
  Z <- F_ret + F_rel + M
  catch_ret <- F_ret/Z * (1 - exp(-Z)) * N
  catch_ret[is.na(catch_ret)] <- 0
  sum(catch_ret)/sum(vul * N) - u
}

